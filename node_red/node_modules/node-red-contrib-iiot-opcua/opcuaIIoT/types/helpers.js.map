{"version":3,"sources":["../src/types/helpers.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;AAwEH;;GAEG;AACI,MAAM,WAAW,GAAG,CAAsC,GAAM,EAAO,EAAE;IAC9E,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAQ,CAAC;AAC/D,CAAC,CAAA;AAFY,QAAA,WAAW,eAEvB","file":"helpers.js","sourcesContent":["/**\n The BSD 3-Clause License\n\n Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n\nimport {TodoTypeAny} from \"./placeholders\";\nimport {AttributeIds, DataType, DataValue, NodeId, NodeIdType, StatusCode} from \"node-opcua\";\nimport {NodeMessageInFlow} from \"node-red\";\n\nexport type TimeUnits =\n  'ms' |\n  's' |\n  'm' |\n  'h';\n\nexport type TimeUnitNames =\n  'msec.' |\n  'sec.' |\n  'min.' |\n  'h.' |\n  '';\n\nexport type WriteMessage = {\n  addressSpaceItems: AddressSpaceItem[]\n  payload: {\n    nodesToWrite: NodeToWrite[],\n  }\n  valuesToWrite?: TodoTypeAny[]\n}\n\nexport type AddressSpaceItem = {\n  nodeId: string\n  browseName: string\n  displayName: string\n  nodeClass: string\n  datatypeName: string\n}\n\nexport type BrowseMessage = {\n  'topic': string\n  'nodeId': string\n  'browseName': string\n  'nodeClassType': string\n  'typeDefinition': string\n  'payload': ''\n}\n\nexport type NodeToWrite = {\n  nodeId: NodeId\n  attributeId: AttributeIds.Value\n  indexRange: null\n  value: DataValue\n}\n\nexport type DataTypeInput = DataType | string;\n\nexport type NodeIdentifier = NodeIdentifierNumeric | NodeIdentifierString;\n\ntype NodeIdentifierNumeric = {\n  identifier: number\n  type: NodeIdType.NUMERIC\n}\n\ntype NodeIdentifierString = {\n  identifier: string\n  type: Exclude<NodeIdType, NodeIdType.NUMERIC>\n}\n\n/**\n * Creates a copy of type <T>, except that all keys are optional.\n */\nexport type Like<T> = {\n  [key in keyof T]?: T[key]\n}\n\n/**\n * Get a list of enum keys from an enum\n */\nexport const getEnumKeys = <O extends object, K extends keyof O>(obj: O): K[] => {\n  return Object.keys(obj).filter(k => Number.isNaN(+k)) as K[];\n}\n\n/**\n * Give a type to NodeMessageInFlow to voerwrite the unknown type\n */\nexport type TypedNodeMessage<T> = NodeMessageInFlow & {\n  payload: T\n}\n\n/**\n * A type used to represent anything that might have status codes\n */\nexport type StatusInput = {\n  statusCodes?: StatusCode[]\n  statusCode?: StatusCode\n};"]}