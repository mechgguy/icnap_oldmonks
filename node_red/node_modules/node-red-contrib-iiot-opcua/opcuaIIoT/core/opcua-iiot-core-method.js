/**
 The BSD 3-Clause License

 Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)
 Copyright (c) 2018-2022 Klaus Landsdorf (http://node-red.plus/)
 All rights reserved.
 node-red-contrib-iiot-opcua
 */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const node_opcua_1 = require("node-opcua");
const opcua_iiot_core_1 = require("./opcua-iiot-core");
const internalDebugLog = (0, debug_1.default)('opcuaIIoT:method'); // eslint-disable-line no-use-before-define
const detailDebugLog = (0, debug_1.default)('opcuaIIoT:method:details'); // eslint-disable-line no-use-before-define
const getArgumentDefinition = function (session, msg) {
    return new Promise(function (resolve, reject) {
        if (!session) {
            reject(new Error('Method Argument Definition Session Not Valid'));
        }
        else {
            try {
                let methodId = (0, node_opcua_1.coerceNodeId)(msg.payload.methodId);
                session.getArgumentDefinition(methodId, function (err, args) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        let results = {};
                        results.methodId = methodId;
                        results.methodDefinition = {};
                        results.methodDefinition.inputArguments = args === null || args === void 0 ? void 0 : args.inputArguments;
                        results.methodDefinition.outputArguments = args === null || args === void 0 ? void 0 : args.outputArguments;
                        resolve(results);
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        }
    });
};
const callMethods = function (session, msg) {
    return new Promise(function (resolve, reject) {
        if (!session) {
            reject(new Error('Methods Call Session Not Valid'));
        }
        else {
            try {
                msg.payload.inputArguments.forEach(function (element) {
                    element.value = (0, opcua_iiot_core_1.convertDataValueByDataType)(element.value, element.dataType);
                });
                let methodCalls = [{
                        objectId: (0, node_opcua_1.coerceNodeId)(msg.payload.objectId),
                        methodId: (0, node_opcua_1.coerceNodeId)(msg.payload.methodId),
                        inputArguments: msg.payload.inputArguments
                    }];
                session.call(methodCalls, function (err, results) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve({ results, msg });
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        }
    });
};
const buildMessagesFromMethodCalls = function (methodCallsResults) {
    return new Promise(function (resolve, reject) {
        if (!methodCallsResults) {
            reject(new Error('Methods Call Results To Messages Session Not Valid'));
        }
        else {
            let resultMessages = [];
            resolve({ methodCallsResults: methodCallsResults, messages: resultMessages });
        }
    });
};
const invalidMessage = function (node, message, handleMethodWarn) {
    let response = false;
    if (!message.payload.objectId) {
        handleMethodWarn('No Object-Id Found For Method Call');
        response = true;
    }
    if (!message.payload.methodId) {
        handleMethodWarn('No Method-Id Found For Method Call');
        response = true;
    }
    if (!message.payload.inputArguments) {
        handleMethodWarn('No Input Arguments Found For Method Call');
        response = true;
    }
    if (!message.payload.methodType) {
        handleMethodWarn('No Method Type Found For Method Call');
        response = true;
    }
    return response;
};
const buildCallMessage = function (node, msg) {
    let message = msg;
    message.payload.objectId = msg.payload.objectId || node.objectId;
    message.payload.methodId = msg.payload.methodId || node.methodId;
    message.payload.methodType = msg.payload.methodType || node.methodType;
    message.payload.inputArguments = msg.payload.inputArguments || node.inputArguments;
    message.payload.nodetype = 'method';
    return message;
};
const coreMethod = {
    internalDebugLog,
    detailDebugLog,
    getArgumentDefinition,
    callMethods,
    buildMessagesFromMethodCalls,
    invalidMessage,
    buildCallMessage,
};
exports.default = coreMethod;

//# sourceMappingURL=opcua-iiot-core-method.js.map
