/**
 The BSD 3-Clause License

 Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)
 Copyright (c) 2018-2022 Klaus Landsdorf (http://node-red.plus/)
 Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)
 All rights reserved.
 node-red-contrib-iiot-opcua
 */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
// @ts-ignore
const node_opcua_1 = require("node-opcua");
const opcua_iiot_core_1 = require("./opcua-iiot-core");
const fsm_1 = require("@xstate/fsm");
const internalDebugLog = (0, debug_1.default)('opcuaIIoT:listener'); // eslint-disable-line no-use-before-define
const detailDebugLog = (0, debug_1.default)('opcuaIIoT:listener:details'); // eslint-disable-line no-use-before-define
const subscribeDebugLog = (0, debug_1.default)('opcuaIIoT:listener:subscribe'); // eslint-disable-line no-use-before-define
const subscribeDetailDebugLog = (0, debug_1.default)('opcuaIIoT:listener:subscribe:details'); // eslint-disable-line no-use-before-define
const eventDebugLog = (0, debug_1.default)('opcuaIIoT:listener:event'); // eslint-disable-line no-use-before-define
const eventDetailDebugLog = (0, debug_1.default)('opcuaIIoT:listener:event:details'); // eslint-disable-line no-use-before-define
const SUBSCRIBE_DEFAULT_INTERVAL = 1000; // eslint-disable-line no-use-before-define
const MIN_LISTENER_INTERVAL = 100; // eslint-disable-line no-use-before-define
const MAX_LISTENER_INTERVAL = 3600000; // eslint-disable-line no-use-before-define
const SUBSCRIBE_DEFAULT_QUEUE_SIZE = 1; // eslint-disable-line no-use-before-define
const EVENT_DEFAULT_INTERVAL = 250; // eslint-disable-line no-use-before-define
const EVENT_DEFAULT_QUEUE_SIZE = 10000; // eslint-disable-line no-use-before-define
const METHOD_TYPE = 'ns=0;i=0'; // eslint-disable-line no-use-before-define
const RUNNING_STATE = opcua_iiot_core_1.FsmListenerStates.StateStarted; // eslint-disable-line no-use-before-define
const MAX_INT32 = 2147483647; // eslint-disable-line no-use-before-define
const createListenerStateMachine = function () {
    return (0, fsm_1.createMachine)({
        id: 'listener',
        initial: opcua_iiot_core_1.FsmListenerStates.StateIdle,
        states: {
            idle: { on: {
                    REQUESTINIT: opcua_iiot_core_1.FsmListenerStates.StateRequested,
                    END: opcua_iiot_core_1.FsmListenerStates.StateEnd
                }
            },
            init: { on: {
                    START: opcua_iiot_core_1.FsmListenerStates.StateStarted,
                    TERMINATE: opcua_iiot_core_1.FsmListenerStates.StateTerminated,
                    ERROR: opcua_iiot_core_1.FsmListenerStates.StateError
                }
            },
            requested: { on: {
                    INIT: opcua_iiot_core_1.FsmListenerStates.StateInit
                }
            },
            started: { on: {
                    TERMINATE: opcua_iiot_core_1.FsmListenerStates.StateTerminated,
                    ERROR: opcua_iiot_core_1.FsmListenerStates.StateError
                }
            },
            error: { on: {
                    IDLE: opcua_iiot_core_1.FsmListenerStates.StateIdle,
                    INIT: opcua_iiot_core_1.FsmListenerStates.StateInit,
                    END: opcua_iiot_core_1.FsmListenerStates.StateEnd
                }
            },
            terminated: { on: {
                    IDLE: opcua_iiot_core_1.FsmListenerStates.StateIdle,
                    ERROR: opcua_iiot_core_1.FsmListenerStates.StateError,
                    END: opcua_iiot_core_1.FsmListenerStates.StateEnd
                }
            },
            end: { on: {} }
        }
    });
};
const startListenerMachineService = (toggleMachine) => {
    return (0, fsm_1.interpret)(toggleMachine).start();
};
const subscribeListenerFSMService = (service, eventFn) => {
    if (service === undefined || eventFn === undefined)
        throw new Error('Service or event handler missing');
    return service.subscribe(eventFn);
};
const getEventSubscriptionParameters = function (timeMilliseconds) {
    timeMilliseconds = timeMilliseconds > MAX_INT32 ? 100 : timeMilliseconds;
    return {
        requestedPublishingInterval: timeMilliseconds || 100,
        requestedLifetimeCount: 1000 * 60 * 20,
        requestedMaxKeepAliveCount: 120,
        maxNotificationsPerPublish: 200,
        publishingEnabled: true,
        priority: 2
    };
};
const getSubscriptionParameters = function (timeMilliseconds) {
    timeMilliseconds = timeMilliseconds > MAX_INT32 ? 200 : timeMilliseconds;
    return {
        requestedPublishingInterval: timeMilliseconds || 200,
        requestedLifetimeCount: 1000 * 60 * 10,
        requestedMaxKeepAliveCount: 60,
        maxNotificationsPerPublish: 100,
        publishingEnabled: true,
        priority: 10
    };
};
const collectAlarmFields = function (field, dataType, value) {
    return {
        field,
        dataType,
        value
    };
};
const getBasicEventFields = function () {
    return ['EventId', 'SourceName', 'Message', 'ReceiveTime'];
};
const getAllEventFields = function () {
    return [
        'ConditionName',
        'ConditionType',
        'ConditionClassId',
        'ConditionClassName',
        'ConditionVariableType',
        'SourceNode',
        'BranchId',
        'EventType',
        'Severity',
        'Retain',
        'Comment',
        'Comment.SourceTimestamp',
        'EnabledState',
        'EnabledState.Id',
        'EnabledState.EffectiveDisplayName',
        'EnabledState.TransitionTime',
        'LastSeverity',
        'LastSeverity.SourceTimestamp',
        'Quality',
        'Quality.SourceTimestamp',
        'Time',
        'ClientUserId',
        'AckedState',
        'AckedState.Id',
        'ConfirmedState',
        'ConfirmedState.Id',
        'LimitState',
        'LimitState.Id',
        'ActiveState',
        'ActiveState.Id'
    ];
};
const getStateFields = function () {
    return [
        'ConditionName',
        'SourceNode',
        'Quality',
        'Time',
        'EnabledState',
        'EnabledState.Id',
        'EnabledState.EffectiveDisplayName',
        'EnabledState.TransitionTime',
        'AckedState',
        'AckedState.Id',
        'ConfirmedState',
        'ConfirmedState.Id',
        'LimitState',
        'LimitState.Id',
        'ActiveState',
        'ActiveState.Id'
    ];
};
const getConditionFields = function () {
    return [
        'Time',
        'Quality',
        'BranchId',
        'SourceNode',
        'ConditionName',
        'ConditionType',
        'ConditionClassId',
        'ConditionClassName',
        'ConditionVariableType'
    ];
};
const monitorItems = function (node, msg, uaSubscription) {
    for (let addressSpaceItem of msg.addressSpaceItems) {
        if (!addressSpaceItem.nodeId) {
            subscribeDebugLog('Address Space Item Not Valid to Monitor ' + addressSpaceItem);
            return;
        }
        if (addressSpaceItem.datatypeName === METHOD_TYPE) {
            subscribeDebugLog('Address Space Item Not Allowed to Monitor ' + addressSpaceItem);
            return;
        }
        const nodeIdToMonitor = (typeof addressSpaceItem.nodeId === 'string') ? addressSpaceItem.nodeId : addressSpaceItem.nodeId.toString();
        if (nodeIdToMonitor) {
            subscribeDebugLog('Monitored Item Subscribing ' + nodeIdToMonitor);
            buildNewMonitoredItem(nodeIdToMonitor, msg, uaSubscription)
                .then(function (result) {
                if (result.monitoredItem.monitoredItemId) {
                    subscribeDebugLog('Monitored Item Subscribed Id:' + result.monitoredItem.monitoredItemId + ' to ' + result.nodeId);
                    node.iiot.monitoredASO.set(result.nodeId.toString(), {
                        monitoredItem: result.monitoredItem,
                        topic: msg.topic || node.topic
                    });
                }
            }).catch(function (err) {
                subscribeDebugLog(err);
                if (node.showErrors) {
                    node.error(err, msg);
                }
            });
        }
    }
};
const buildNewMonitoredItem = function (nodeId, msg, subscription) {
    return new Promise(function (resolve, reject) {
        if (!nodeId) {
            reject(new Error('NodeId Is Not Valid'));
            return;
        }
        let interval;
        let queueSize;
        let options = (msg.payload.listenerParameters) ? msg.payload.listenerParameters : msg.payload;
        if (typeof options.interval === 'number' &&
            options.interval <= MAX_LISTENER_INTERVAL &&
            options.interval >= MIN_LISTENER_INTERVAL) {
            interval = parseInt(options.interval);
        }
        else {
            interval = SUBSCRIBE_DEFAULT_INTERVAL;
        }
        if (options.queueSize && typeof options.queueSize === 'number') {
            queueSize = parseInt(options.queueSize);
        }
        else {
            queueSize = SUBSCRIBE_DEFAULT_QUEUE_SIZE;
        }
        subscription.monitor({
            nodeId: (0, node_opcua_1.resolveNodeId)(nodeId),
            attributeId: node_opcua_1.AttributeIds.Value
        }, {
            samplingInterval: interval,
            discardOldest: true,
            queueSize: queueSize
        }, node_opcua_1.TimestampsToReturn.Both, function (err, monitoredItemResult) {
            if (err) {
                internalDebugLog('subscribing monitored item ' + err);
                reject(err);
            }
            else {
                resolve({ nodeId: nodeId, monitoredItem: monitoredItemResult });
            }
        });
    });
};
const buildNewMonitoredItemGroup = function (node, msg, addressSpaceItems, subscription) {
    return new Promise(function (resolve, reject) {
        if (!addressSpaceItems) {
            reject(new Error('NodeId Is Not Valid'));
            return;
        }
        let interval;
        let queueSize;
        let options = (msg.payload.listenerParameters) ? msg.payload.listenerParameters : msg.payload;
        if (typeof options.interval === 'number' &&
            options.interval <= MAX_LISTENER_INTERVAL &&
            options.interval >= MIN_LISTENER_INTERVAL) {
            interval = parseInt(options.interval);
        }
        else {
            interval = SUBSCRIBE_DEFAULT_INTERVAL;
        }
        if (options.queueSize && typeof options.queueSize === 'number') {
            queueSize = parseInt(options.queueSize);
        }
        else {
            queueSize = SUBSCRIBE_DEFAULT_QUEUE_SIZE;
        }
        let filteredAddressSpaceItems = addressSpaceItems.filter((addressSpaceItem) => {
            return addressSpaceItem.datatypeName !== METHOD_TYPE;
        });
        let subcriptionItems = [];
        filteredAddressSpaceItems.forEach((item) => {
            subcriptionItems.push({
                nodeId: (0, node_opcua_1.resolveNodeId)(item.nodeId),
                attributeId: node_opcua_1.AttributeIds.Value
            });
        });
        subscription.monitorItems(subcriptionItems, {
            samplingInterval: interval,
            discardOldest: true,
            queueSize: queueSize
        }, node_opcua_1.TimestampsToReturn.Both, function (err, monitoredItemGroup) {
            if (err) {
                internalDebugLog('subscribing monitored item group ' + err);
                reject(err);
            }
            else {
                resolve({ addressSpaceItems: addressSpaceItems, monitoredItemGroup: monitoredItemGroup });
            }
        });
    });
};
const buildNewEventItem = function (nodeId, msg, subscription) {
    return new Promise(function (resolve, reject) {
        if (!nodeId) {
            reject(new Error('NodeId Is Not Valid'));
            return;
        }
        let interval;
        let queueSize;
        if (typeof msg.payload.interval === 'number' && msg.payload.interval < MAX_LISTENER_INTERVAL) {
            interval = parseInt(msg.payload.interval);
        }
        else {
            interval = EVENT_DEFAULT_INTERVAL;
        }
        if (typeof msg.payload.queueSize === 'number') {
            queueSize = parseInt(msg.payload.queueSize);
        }
        else {
            queueSize = EVENT_DEFAULT_QUEUE_SIZE;
        }
        subscription.monitor({
            nodeId: (0, node_opcua_1.resolveNodeId)(nodeId),
            attributeId: node_opcua_1.AttributeIds.EventNotifier
        }, {
            samplingInterval: interval,
            discardOldest: true,
            queueSize: queueSize,
            filter: msg.payload.eventFilter
        }, node_opcua_1.TimestampsToReturn.Both, function (err, monitoredItemResult) {
            if (err) {
                internalDebugLog('subscribing event item ' + err);
                reject(err);
            }
            else {
                resolve({ nodeId: nodeId, monitoredItem: monitoredItemResult });
            }
        });
    });
};
const analyzeEvent = function (session, browseForBrowseName, dataValue) {
    return new Promise(function (resolve, reject) {
        if (!session) {
            reject(new Error('Session Is Not Valid To Analyze Event'));
            return;
        }
        if (!browseForBrowseName || typeof browseForBrowseName !== 'function') {
            reject(new Error('BrowseForBrowseName Is Not Valid Function'));
            return;
        }
        if (!dataValue) {
            reject(new Error('Event Response Not Valid'));
        }
        else {
            let index = 0;
            let eventInformation = {};
            let eventResults = [];
            dataValue.forEach((dv) => {
                var _a;
                const variant = dv.value;
                eventDebugLog('variant entry: ' + (variant === null || variant === void 0 ? void 0 : variant.toString()));
                try {
                    if (variant.dataType && variant.value) {
                        eventInformation = collectAlarmFields(dataValue.monitoringParameters.filter.selectClauses[index], (_a = variant === null || variant === void 0 ? void 0 : variant.dataType) === null || _a === void 0 ? void 0 : _a.toString(), variant.value);
                        if (variant.dataType === node_opcua_1.DataType.NodeId) {
                            browseForBrowseName(session, variant.value, function (err, browseName) {
                                if (err) {
                                    reject(err);
                                }
                                else {
                                    eventInformation.browseName = browseName;
                                    eventResults.push({ eventInformation: eventInformation, eventData: variant === null || variant === void 0 ? void 0 : variant.toJSON() });
                                }
                            });
                        }
                        else {
                            eventResults.push({ eventInformation: eventInformation, eventData: variant === null || variant === void 0 ? void 0 : variant.toJSON() });
                        }
                    }
                    index++;
                }
                catch (err) {
                    eventInformation = { error: err };
                    eventResults.push({ eventInformation: eventInformation, eventData: variant === null || variant === void 0 ? void 0 : variant.toJSON() });
                }
            });
            resolve(eventResults.flat());
        }
    });
};
const checkState = function (node, msg, callerType) {
    internalDebugLog('Check Listener State ' + node.iiot.stateService.state.value + ' By ' + callerType);
    if (node.connector && node.iiot.stateService && node.iiot.stateService.state.value !== RUNNING_STATE) {
        internalDebugLog('Wrong Listener State ' + node.iiot.stateService.state.value + ' By ' + callerType);
        if (node.showErrors) {
            node.error(new Error('Listener Not ' + RUNNING_STATE + ' On ' + callerType), msg);
        }
        return false;
    }
    else {
        return true;
    }
};
const initListenerNode = function () {
    return Object.assign(Object.assign({}, (0, opcua_iiot_core_1.initCoreNode)()), { opcuaSubscription: null, monitoredItems: new Map(), monitoredASO: new Map(), messageQueue: [] });
};
const coreListener = {
    internalDebugLog,
    detailDebugLog,
    subscribeDebugLog,
    subscribeDetailDebugLog,
    eventDebugLog,
    eventDetailDebugLog,
    SUBSCRIBE_DEFAULT_INTERVAL,
    MIN_LISTENER_INTERVAL,
    MAX_LISTENER_INTERVAL,
    SUBSCRIBE_DEFAULT_QUEUE_SIZE,
    EVENT_DEFAULT_INTERVAL,
    EVENT_DEFAULT_QUEUE_SIZE,
    METHOD_TYPE,
    RUNNING_STATE,
    MAX_INT32,
    createListenerStateMachine,
    startListenerMachineService,
    subscribeListenerFSMService,
    getEventSubscriptionParameters,
    getSubscriptionParameters,
    collectAlarmFields,
    getBasicEventFields,
    getAllEventFields,
    getStateFields,
    getConditionFields,
    monitorItems,
    buildNewMonitoredItem,
    buildNewMonitoredItemGroup,
    buildNewEventItem,
    analyzeEvent,
    checkState,
    initListenerNode,
};
exports.default = coreListener;

//# sourceMappingURL=opcua-iiot-core-listener.js.map
