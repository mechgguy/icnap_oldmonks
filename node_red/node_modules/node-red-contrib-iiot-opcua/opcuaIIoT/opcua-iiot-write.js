/*
 The BSD 3-Clause License

 Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)
 Copyright (c) 2018-2022 Klaus Landsdorf (http://node-red.plus/)
 Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)
 All rights reserved.
 node-red-contrib-iiot-opcua
 */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const opcua_iiot_core_client_1 = __importDefault(require("./core/opcua-iiot-core-client"));
const opcua_iiot_core_1 = require("./core/opcua-iiot-core");
/**
 * Write Node-RED node.
 *
 * @param RED
 */
module.exports = (RED) => {
    // SOURCE-MAP-REQUIRED
    function OPCUAIIoTWrite(config) {
        RED.nodes.createNode(this, config);
        this.name = config.name;
        this.justValue = config.justValue;
        this.showStatusActivities = config.showStatusActivities;
        this.showErrors = config.showErrors;
        this.connector = RED.nodes.getNode(config.connector);
        let self = this;
        self.iiot = (0, opcua_iiot_core_1.initCoreNode)();
        const handleWriteError = (err, msg) => {
            opcua_iiot_core_client_1.default.writeDebugLog(err);
            if (self.showErrors) {
                this.error(err, msg);
            }
            /* istanbul ignore next */
            if ((0, opcua_iiot_core_1.isSessionBad)(err)) {
                this.emit('opcua_client_not_ready');
            }
        };
        const writeToSession = (session, originMsg) => {
            if ((0, opcua_iiot_core_1.checkSessionNotValid)(session, 'Writer')) {
                /* istanbul ignore next */
                return;
            }
            let msg = Object.assign({}, originMsg);
            const nodesToWrite = (0, opcua_iiot_core_1.buildNodesToWrite)(msg);
            opcua_iiot_core_client_1.default.write(session, nodesToWrite, msg).then((writeResult) => {
                try {
                    let message = buildResultMessage(writeResult);
                    this.send(message);
                }
                catch (err) {
                    /* istanbul ignore next */
                    (0, opcua_iiot_core_1.isInitializedIIoTNode)(self) ? handleWriteError(err, msg) : opcua_iiot_core_client_1.default.internalDebugLog(err.message);
                }
            }).catch(function (err) {
                /* istanbul ignore next */
                (0, opcua_iiot_core_1.isInitializedIIoTNode)(self) ? handleWriteError(err, msg) : opcua_iiot_core_client_1.default.internalDebugLog(err.message);
            });
        };
        const buildResultMessage = (result) => {
            let message = Object.assign({}, result.msg);
            message.payload.nodetype = 'write';
            message.payload.justValue = self.justValue;
            message.payload.value = extractDataValue(message, result);
            return message;
        };
        const extractDataValue = (message, result) => {
            let dataValues;
            if (self.justValue) {
                if (message.payload.valuesToWrite) {
                    delete message.payload['valuesToWrite'];
                }
                return {
                    statusCodes: result.statusCodes
                };
            }
            else {
                delete result['msg'];
                return result;
            }
        };
        const errorHandler = (err, msg) => {
            this.error(err, msg);
        };
        const emitHandler = (msg) => {
            this.emit(msg);
        };
        const statusHandler = (status) => {
            this.status(status);
        };
        this.on('input', (msg) => {
            if (!(0, opcua_iiot_core_1.checkConnectorState)(self, msg, 'Write', errorHandler, emitHandler, statusHandler)) {
                return;
            }
            const payload = msg.payload;
            // recursivePrintTypes(msg);
            if (payload.injectType === 'write') {
                writeToSession(self.connector.iiot.opcuaSession, msg);
            }
            else {
                opcua_iiot_core_client_1.default.writeDebugLog('Wrong Inject Type ' + payload.injectType + '! The Type has to be write.');
                /* istanbul ignore next */
                if (self.showErrors) {
                    this.warn('Wrong Inject Type ' + payload.injectType + '! The msg.payload.injectType has to be write.');
                }
            }
        });
        const onAlias = (event, callback) => {
            // @ts-ignore
            this.on(event, callback);
        };
        (0, opcua_iiot_core_1.registerToConnector)(self, statusHandler, onAlias, errorHandler);
        this.on('close', (done) => {
            self.removeAllListeners();
            (0, opcua_iiot_core_1.deregisterToConnector)(self, () => {
                (0, opcua_iiot_core_1.resetIiotNode)(self);
                done();
            });
        });
        if (process.env.TEST === "true") {
            self.functions = {
                handleWriteError
            };
        }
    }
    RED.nodes.registerType('OPCUA-IIoT-Write', OPCUAIIoTWrite);
};

//# sourceMappingURL=opcua-iiot-write.js.map
