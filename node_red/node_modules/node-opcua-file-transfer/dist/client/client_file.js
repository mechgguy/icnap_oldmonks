"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientFile = exports.OpenFileMode = void 0;
/**
 * @module node-opcua-file-transfer
 */
const node_opcua_basic_types_1 = require("node-opcua-basic-types");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_service_translate_browse_path_1 = require("node-opcua-service-translate-browse-path");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_constants_1 = require("node-opcua-constants");
const node_opcua_debug_1 = require("node-opcua-debug");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("FileType");
const errorLog = (0, node_opcua_debug_1.make_errorLog)("FileType");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("FileType");
const open_mode_1 = require("../open_mode");
var open_mode_2 = require("../open_mode");
Object.defineProperty(exports, "OpenFileMode", { enumerable: true, get: function () { return open_mode_2.OpenFileMode; } });
/**
 *
 *
 */
class ClientFile {
    constructor(session, nodeId) {
        this.fileHandle = 0;
        this.session = session;
        this.nodeId = nodeId;
    }
    /**
     * @deprecated use nodeId instead
     */
    get fileNodeId() {
        return this.nodeId;
    }
    async browseName() {
        const dataValue = await this.session.read({ nodeId: this.nodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName });
        return dataValue.value.value;
    }
    async open(mode) {
        if (mode === null || mode === undefined) {
            throw new Error("expecting a validMode " + open_mode_1.OpenFileMode[mode]);
        }
        if (this.fileHandle) {
            throw new Error("File has already be opened");
        }
        await this.ensureInitialized();
        const result = await this.session.call({
            inputArguments: [{ dataType: node_opcua_variant_1.DataType.Byte, value: mode }],
            methodId: this.openMethodNodeId,
            objectId: this.nodeId
        });
        if (result.statusCode.isNotGood()) {
            debugLog("Cannot open file : ");
            throw new Error("cannot open file statusCode = " + result.statusCode.toString() + " mode = " + open_mode_1.OpenFileMode[mode]);
        }
        this.fileHandle = result.outputArguments[0].value;
        return this.fileHandle;
    }
    async close() {
        if (!this.fileHandle) {
            throw new Error("File has not been opened yet");
        }
        await this.ensureInitialized();
        const result = await this.session.call({
            inputArguments: [{ dataType: node_opcua_variant_1.DataType.UInt32, value: this.fileHandle }],
            methodId: this.closeMethodNodeId,
            objectId: this.nodeId
        });
        if (result.statusCode.isNotGood()) {
            debugLog("Cannot close file : ");
            throw new Error("cannot close file statusCode = " + result.statusCode.toString());
        }
        this.fileHandle = 0;
    }
    async getPosition() {
        await this.ensureInitialized();
        if (!this.fileHandle) {
            throw new Error("File has not been opened yet");
        }
        const result = await this.session.call({
            inputArguments: [{ dataType: node_opcua_variant_1.DataType.UInt32, value: this.fileHandle }],
            methodId: this.getPositionNodeId,
            objectId: this.nodeId
        });
        if (result.statusCode.isNotGood()) {
            throw new Error("Error " + result.statusCode.toString());
        }
        return result.outputArguments[0].value;
    }
    async setPosition(position) {
        await this.ensureInitialized();
        if (!this.fileHandle) {
            throw new Error("File has not been opened yet");
        }
        if (typeof position === "number") {
            position = [0, position];
        }
        const result = await this.session.call({
            inputArguments: [
                { dataType: node_opcua_variant_1.DataType.UInt32, value: this.fileHandle },
                {
                    arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                    dataType: node_opcua_variant_1.DataType.UInt64,
                    value: position
                }
            ],
            methodId: this.setPositionNodeId,
            objectId: this.nodeId
        });
        if (result.statusCode.isNotGood()) {
            throw new Error("Error " + result.statusCode.toString());
        }
        return;
    }
    async read(bytesToRead) {
        await this.ensureInitialized();
        if (!this.fileHandle) {
            throw new Error("File has not been opened yet");
        }
        const result = await this.session.call({
            inputArguments: [
                { dataType: node_opcua_variant_1.DataType.UInt32, value: this.fileHandle },
                {
                    arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                    dataType: node_opcua_variant_1.DataType.Int32,
                    value: (0, node_opcua_basic_types_1.coerceInt32)(bytesToRead)
                }
            ],
            methodId: this.readNodeId,
            objectId: this.nodeId
        });
        if (result.statusCode.isNotGood()) {
            throw new Error("Error " + result.statusCode.toString());
        }
        if (!result.outputArguments || result.outputArguments[0].dataType !== node_opcua_variant_1.DataType.ByteString) {
            throw new Error("Error invalid output");
        }
        return result.outputArguments[0].value;
    }
    async write(data) {
        await this.ensureInitialized();
        if (!this.fileHandle) {
            throw new Error("File has not been opened yet");
        }
        const result = await this.session.call({
            inputArguments: [
                { dataType: node_opcua_variant_1.DataType.UInt32, value: this.fileHandle },
                {
                    arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                    dataType: node_opcua_variant_1.DataType.ByteString,
                    value: data
                }
            ],
            methodId: this.writeNodeId,
            objectId: this.nodeId
        });
        if (result.statusCode.isNotGood()) {
            throw new Error("Error " + result.statusCode.toString());
        }
        return;
    }
    async openCount() {
        await this.ensureInitialized();
        const nodeToRead = { nodeId: this.openCountNodeId, attributeId: node_opcua_data_model_1.AttributeIds.Value };
        const dataValue = await this.session.read(nodeToRead);
        // istanbul ignore next
        if (doDebug) {
            debugLog(" OpenCount ", nodeToRead.nodeId.toString(), dataValue.toString());
        }
        return dataValue.value.value;
    }
    async size() {
        await this.ensureInitialized();
        const nodeToRead = { nodeId: this.sizeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.Value };
        const dataValue = await this.session.read(nodeToRead);
        return dataValue.value.value;
    }
    // eslint-disable-next-line max-statements
    async extractMethodsIds() {
        if (ClientFile.useGlobalMethod) {
            debugLog("Using GlobalMethodId");
            this.openMethodNodeId = (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.MethodIds.FileType_Open);
            this.closeMethodNodeId = (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.MethodIds.FileType_Close);
            this.setPositionNodeId = (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.MethodIds.FileType_SetPosition);
            this.getPositionNodeId = (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.MethodIds.FileType_GetPosition);
            this.writeNodeId = (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.MethodIds.FileType_Write);
            this.readNodeId = (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.MethodIds.FileType_Read);
            const browsePaths = [(0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/OpenCount"), (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/Size")];
            const results = await this.session.translateBrowsePath(browsePaths);
            if (results[0].statusCode.isNotGood()) {
                throw new Error("fileType object does not expose mandatory OpenCount Property");
            }
            if (results[1].statusCode.isNotGood()) {
                throw new Error("fileType object does not expose mandatory Size Property");
            }
            this.openCountNodeId = results[0].targets[0].targetId;
            this.sizeNodeId = results[1].targets[0].targetId;
            return;
        }
        const browsePaths = [
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/Open"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/Close"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/SetPosition"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/GetPosition"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/Write"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/Read"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/OpenCount"),
            (0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(this.nodeId, "/Size")
        ];
        const results = await this.session.translateBrowsePath(browsePaths);
        if (results[0].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory Open Method");
        }
        if (results[1].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory Close Method");
        }
        if (results[2].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory SetPosition Method");
        }
        if (results[3].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory GetPosition Method");
        }
        if (results[4].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory Write Method");
        }
        if (results[5].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory Read Method");
        }
        if (results[6].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory OpenCount Variable");
        }
        if (results[7].statusCode.isNotGood()) {
            throw new Error("fileType object does not expose mandatory Size Variable");
        }
        if (false && doDebug) {
            results.map((x) => debugLog(x.toString()));
        }
        this.openMethodNodeId = results[0].targets[0].targetId;
        this.closeMethodNodeId = results[1].targets[0].targetId;
        this.setPositionNodeId = results[2].targets[0].targetId;
        this.getPositionNodeId = results[3].targets[0].targetId;
        this.writeNodeId = results[4].targets[0].targetId;
        this.readNodeId = results[5].targets[0].targetId;
        this.openCountNodeId = results[6].targets[0].targetId;
        this.sizeNodeId = results[7].targets[0].targetId;
    }
    async ensureInitialized() {
        if (!this.openMethodNodeId) {
            await this.extractMethodsIds();
        }
    }
}
exports.ClientFile = ClientFile;
ClientFile.useGlobalMethod = false;
/**
 * 5.2.10 UserRolePermissions
 *
 * The optional UserRolePermissions Attribute specifies the Permissions that apply to a Node for
 * all Roles granted to current Session. The value of the Attribute is an array of
 * RolePermissionType Structures (see Table 8).
 * Clients may determine their effective Permissions by logically ORing the Permissions for each
 * Role in the array.
 *  The value of this Attribute is derived from the rules used by the Server to map Sessions to
 * Roles. This mapping may be vendor specific or it may use the standard Role model defined in 4.8.
 * This Attribute shall not be writeable.
 * If not specified, the value of DefaultUserRolePermissions Property from the Namespace
 * Metadata Object associated with the Node is used instead. If the NamespaceMetadata Object
 * does not define the Property or does not exist, then the Server does not publish any information
 * about Roles mapped to the current Session.
 *
 *
 * 5.2.11 AccessRestrictions
 * The optional AccessRestrictions Attribute specifies the AccessRestrictions that apply to a Node.
 * Its data type is defined in 8.56. If a Server supports AccessRestrictions for a particular
 * Namespace it adds the DefaultAccessRestrictions Property to the NamespaceMetadata Object
 * for that Namespace (see Figure 8). If a particular Node in the Namespace needs to override
 * the default value the Server adds the AccessRestrictions Attribute to the Node.
 * If a Server implements a vendor specific access restriction model for a Namespace, it does not
 * add the DefaultAccessRestrictions Property to the NamespaceMetadata Object.
 *
 *
 * DefaultAccessRestrictions
 *
 */
//# sourceMappingURL=client_file.js.map