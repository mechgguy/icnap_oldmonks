"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFile = readFile;
exports.readOPCUAFile = readOPCUAFile;
const node_opcua_basic_types_1 = require("node-opcua-basic-types");
const client_file_1 = require("./client_file");
const read_max_byte_string_length_1 = require("./read_max_byte_string_length");
const get_transport_max_size_1 = require("./get_transport_max_size");
async function readFile(clientFile, options) {
    options = options || { chunkSize: await (0, read_max_byte_string_length_1.readMaxByteStringLength)(clientFile.session) };
    let maxBlockSize = options.chunkSize || 1024;
    const transportMaxSize = (0, get_transport_max_size_1.getTransportMaxMessageSize)(clientFile.session);
    maxBlockSize = transportMaxSize > 0 ? Math.min(maxBlockSize, transportMaxSize) : maxBlockSize;
    await clientFile.open(client_file_1.OpenFileMode.Read);
    try {
        const fileSize = (0, node_opcua_basic_types_1.coerceInt32)(await clientFile.size());
        /**
         *  Read file
         */
        const data = await clientFile.read(Math.min(fileSize, maxBlockSize));
        if (data.length >= fileSize) {
            // everything has been read
            return data;
        }
        // wee need to loop to complete the read
        const chunks = [data];
        let remaining = fileSize - data.length;
        while (remaining > 0) {
            const buf = await clientFile.read(Math.min(remaining, maxBlockSize));
            if (buf.length === 0)
                break;
            chunks.push(buf);
            remaining -= buf.length;
        }
        return Buffer.concat(chunks);
    }
    finally {
        await clientFile.close();
    }
}
async function readOPCUAFile(clientFile) {
    return await readFile(clientFile);
}
//# sourceMappingURL=read_file.js.map