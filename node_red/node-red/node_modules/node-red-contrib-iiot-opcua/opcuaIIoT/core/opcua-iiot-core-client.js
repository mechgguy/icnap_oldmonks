/**
 The BSD 3-Clause License

 Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)
 Copyright (c) 2018-2022 Klaus Landsdorf (http://node-red.plus/)
 Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)
 All rights reserved.
 node-red-contrib-iiot-opcua
 */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const internalDebugLog = (0, debug_1.default)('opcuaIIoT:client'); // eslint-disable-line no-use-before-define
const detailDebugLog = (0, debug_1.default)('opcuaIIoT:client:details'); // eslint-disable-line no-use-before-define
const readDebugLog = (0, debug_1.default)('opcuaIIoT:client:read'); // eslint-disable-line no-use-before-define
const readDetailsDebugLog = (0, debug_1.default)('opcuaIIoT:client:read:details'); // eslint-disable-line no-use-before-define
const writeDebugLog = (0, debug_1.default)('opcuaIIoT:client:write'); // eslint-disable-line no-use-before-define
const writeDetailsDebugLog = (0, debug_1.default)('opcuaIIoT:client:write:details'); // eslint-disable-line no-use-before-define
const READ_TYPE = Object.freeze({
    ALL: 0,
    NODE_ID: 1,
    NODE_CLASS: 2,
    BROWSE_NAME: 3,
    DISPLAY_NAME: 4,
    VALUE: 13,
    HISTORY: 130
}); // eslint-disable-line no-use-before-define
const write = (session, nodesToWrite, originMsg) => {
    return new Promise((resolve, reject) => {
        if (session) {
            let msg = Object.assign({}, originMsg);
            session.write(nodesToWrite, (err, statusCodes) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        statusCodes,
                        nodesToWrite,
                        msg
                    });
                }
            });
        }
        else {
            reject(new Error('ClientSessionWriteService Not Valid To Write'));
        }
    });
};
const read = function (session, nodesToRead, maxAge, msg) {
    return new Promise(function (resolve, reject) {
        if (session) {
            session.read(nodesToRead, maxAge, function (err, dataValues) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        results: dataValues,
                        nodesToRead,
                        msg
                    });
                }
            });
        }
        else {
            reject(new Error('ClientSessionReadService Not Valid To Read'));
        }
    });
};
const readVariableValue = function (session, nodesToRead, originMsg) {
    return new Promise(function (resolve, reject) {
        if (session) {
            let msg = Object.assign({}, originMsg);
            session.read(nodesToRead, function (err, dataValues) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        results: dataValues,
                        nodesToRead,
                        msg
                    });
                }
            });
        }
        else {
            reject(new Error('ClientSessionReadService Not Valid To Read Variable Value'));
        }
    });
};
const readHistoryValue = function (session, nodesToRead, startDate, endDate, originMsg) {
    return new Promise(function (resolve, reject) {
        if (session) {
            let msg = Object.assign({}, originMsg);
            session.readHistoryValue(nodesToRead, startDate, endDate, function (err, results) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        results,
                        nodesToRead,
                        startDate,
                        endDate,
                        msg
                    });
                }
            });
        }
        else {
            reject(new Error('ClientSessionReadHistoryService Not Valid To Read History Value'));
        }
    });
};
const readAllAttributes = function (session, nodesToRead, originMsg) {
    return new Promise(function (resolve, reject) {
        if (session) {
            let msg = Object.assign({}, originMsg);
            const nodeIdStrings = nodesToRead.map((item) => item.nodeId || item);
            // @ts-ignore see ClientSessionImpl
            session.readAllAttributes(nodeIdStrings, function (err, data) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        results: data,
                        nodesToRead,
                        msg
                    });
                }
            });
        }
        else {
            reject(new Error('ClientSessionReadService Not Valid To Read All Attributes'));
        }
    });
};
const stringifyFormatted = function (dataValues) {
    return JSON.stringify(dataValues, null, 2);
};
const coreClient = {
    internalDebugLog,
    detailDebugLog,
    readDebugLog,
    readDetailsDebugLog,
    writeDebugLog,
    writeDetailsDebugLog,
    READ_TYPE,
    write,
    read,
    readVariableValue,
    readHistoryValue,
    readAllAttributes,
    stringifyFormatted,
};
exports.default = coreClient;

//# sourceMappingURL=opcua-iiot-core-client.js.map
