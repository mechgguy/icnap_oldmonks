{"version":3,"sources":["../src/core/opcua-iiot-core-client.ts"],"names":[],"mappings":"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","file":"opcua-iiot-core-client.js","sourcesContent":["/**\n The BSD 3-Clause License\n\n Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)\n Copyright (c) 2018-2022 Klaus Landsdorf (http://node-red.plus/)\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n// SOURCE-MAP-REQUIRED\n\n\nimport {TodoTypeAny} from \"../types/placeholders\";\n\nimport debug from \"debug\";\nimport {ClientSession, ClientSessionWriteService, DataValue, NodeAttributes, StatusCode, StatusCodes} from \"node-opcua\";\nimport {ReadValueIdOptions} from \"node-opcua-service-read\";\nimport {WriteValueOptions} from \"node-opcua-service-write\";\nimport {WriteResult} from \"../opcua-iiot-write\";\nimport {ClientSessionReadHistoryService, ClientSessionReadService} from \"node-opcua-client/source/client_session\";\nimport {HistoryReadResult} from \"node-opcua-service-history\";\nimport {AddressSpaceItem} from \"../types/helpers\";\nimport {NodeIdLike} from \"node-opcua-nodeid\";\n\nconst internalDebugLog = debug('opcuaIIoT:client') // eslint-disable-line no-use-before-define\nconst detailDebugLog = debug('opcuaIIoT:client:details') // eslint-disable-line no-use-before-define\nconst readDebugLog = debug('opcuaIIoT:client:read') // eslint-disable-line no-use-before-define\nconst readDetailsDebugLog = debug('opcuaIIoT:client:read:details') // eslint-disable-line no-use-before-define\nconst writeDebugLog = debug('opcuaIIoT:client:write') // eslint-disable-line no-use-before-define\nconst writeDetailsDebugLog = debug('opcuaIIoT:client:write:details') // eslint-disable-line no-use-before-define\n\n\nconst READ_TYPE = Object.freeze({\n  ALL: 0,\n  NODE_ID: 1,\n  NODE_CLASS: 2,\n  BROWSE_NAME: 3,\n  DISPLAY_NAME: 4,\n  VALUE: 13,\n  HISTORY: 130\n}) // eslint-disable-line no-use-before-define\n\nconst write = (session: ClientSessionWriteService, nodesToWrite: WriteValueOptions[], originMsg: TodoTypeAny): Promise<WriteResult> => {\n  return new Promise(\n    (resolve, reject) => {\n      if (session) {\n        let msg = Object.assign({}, originMsg)\n        session.write(nodesToWrite, (err: Error | null, statusCodes?: StatusCode[]) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve({\n              statusCodes,\n              nodesToWrite,\n              msg\n            })\n          }\n        })\n      } else {\n        reject(new Error('ClientSessionWriteService Not Valid To Write'))\n      }\n    }\n  )\n}\n\nconst read = function (session: ClientSessionReadService, nodesToRead: ReadValueIdOptions[], maxAge: number, msg: TodoTypeAny) {\n  return new Promise(\n    function (resolve, reject) {\n      if (session) {\n        session.read(nodesToRead, maxAge, function (err: Error | null, dataValues?: DataValue[]) {\n          if (err) {\n            reject(err)\n          } else {\n            resolve({\n              results: dataValues,\n              nodesToRead,\n              msg\n            })\n          }\n        })\n      } else {\n        reject(new Error('ClientSessionReadService Not Valid To Read'))\n      }\n    }\n  )\n}\n\nconst readVariableValue = function (session: ClientSessionReadService, nodesToRead: TodoTypeAny, originMsg: TodoTypeAny) {\n  return new Promise(\n    function (resolve, reject) {\n      if (session) {\n        let msg = Object.assign({}, originMsg)\n        session.read(nodesToRead, function (err: Error | null, dataValues?: DataValue[]) {\n          if (err) {\n            reject(err)\n          } else {\n            resolve({\n              results: dataValues,\n              nodesToRead,\n              msg\n            })\n          }\n        })\n      } else {\n        reject(new Error('ClientSessionReadService Not Valid To Read Variable Value'))\n      }\n    }\n  )\n}\n\nconst readHistoryValue = function (session: ClientSessionReadHistoryService, nodesToRead: TodoTypeAny, startDate: TodoTypeAny, endDate: TodoTypeAny, originMsg: TodoTypeAny) {\n  return new Promise(\n    function (resolve, reject) {\n      if (session) {\n        let msg = Object.assign({}, originMsg)\n        session.readHistoryValue(nodesToRead, startDate, endDate, function (err: Error | null, results?: HistoryReadResult[]) {\n          if (err) {\n            reject(err)\n          } else {\n            resolve({\n              results,\n              nodesToRead,\n              startDate,\n              endDate,\n              msg\n            })\n          }\n        })\n      } else {\n        reject(new Error('ClientSessionReadHistoryService Not Valid To Read History Value'))\n      }\n    }\n  )\n}\n\nconst readAllAttributes = function (session: ClientSession, nodesToRead: TodoTypeAny[], originMsg: TodoTypeAny) {\n  return new Promise(\n    function (resolve, reject) {\n      if (session) {\n        let msg = Object.assign({}, originMsg)\n        const nodeIdStrings = nodesToRead.map( (item: TodoTypeAny | string) => item.nodeId || item )\n        // @ts-ignore see ClientSessionImpl\n        session.readAllAttributes(nodeIdStrings, function (err: Error | null, data?: NodeAttributes[]) {\n          if (err) {\n            reject(err)\n          } else {\n            resolve({\n              results: data,\n              nodesToRead,\n              msg\n            })\n          }\n        })\n      } else {\n        reject(new Error('ClientSessionReadService Not Valid To Read All Attributes'))\n      }\n    }\n  )\n}\n\nconst stringifyFormatted = function (dataValues: TodoTypeAny) {\n  return JSON.stringify(dataValues, null, 2)\n}\n\nconst coreClient = {\n  internalDebugLog,\n  detailDebugLog,\n  readDebugLog,\n  readDetailsDebugLog,\n  writeDebugLog,\n  writeDetailsDebugLog,\n\n  READ_TYPE,\n  write,\n  read,\n  readVariableValue,\n  readHistoryValue,\n  readAllAttributes,\n  stringifyFormatted,\n}\n\nexport default coreClient\n"]}