/*
 The BSD 3-Clause License

 Copyright 2022 - DATATRONiQ GmbH (https://datatroniq.com)
 Copyright (c) 2018-2022 Klaus Landsdorf (http://node-red.plus/)
 Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)
 All rights reserved.
 node-red-contrib-iiot-opcua
 */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_opcua_1 = require("node-opcua");
const opcua_iiot_core_listener_1 = __importDefault(require("./core/opcua-iiot-core-listener"));
/**
 * Event Node-RED node.
 *
 * @param RED
 */
module.exports = function (RED) {
    // SOURCE-MAP-REQUIRED
    function OPCUAIIoTEvent(config) {
        RED.nodes.createNode(this, config);
        this.eventType = config.eventType;
        this.eventTypeLabel = config.eventTypeLabel;
        this.resultType = config.resultType || 'basic';
        this.queueSize = config.queueSize;
        this.usingListener = config.usingListener;
        this.name = config.name;
        this.showStatusActivities = config.showStatusActivities;
        this.showErrors = config.showErrors;
        let self = this;
        self.iiot = {};
        const statusCall = (status) => {
            this.status(status);
        };
        self.iiot.subscribed = false;
        statusCall({ fill: 'blue', shape: 'ring', text: 'new' });
        this.on('input', (msg) => {
            self.iiot.subscribed = !self.iiot.subscribed;
            if (self.usingListener) {
                if (self.iiot.subscribed) {
                    statusCall({ fill: 'blue', shape: 'dot', text: 'subscribed' });
                }
                else {
                    statusCall({ fill: 'blue', shape: 'ring', text: 'not subscribed' });
                }
            }
            else {
                statusCall({ fill: 'blue', shape: 'dot', text: 'injected' });
            }
            const uaEventFields = [
                ...opcua_iiot_core_listener_1.default.getBasicEventFields(),
                ...getAdditionalEventFields()
            ];
            const interval = msg.payload.value;
            const uaEventFilter = (0, node_opcua_1.constructEventFilter)(uaEventFields);
            const responsePayload = Object.assign(Object.assign({}, msg.payload), { eventType: self.eventType, uaEventFilter: uaEventFilter, uaEventFields: uaEventFields, nodetype: 'events', queueSize: self.queueSize, interval: typeof interval === 'number' ? interval : 1000 });
            const responseMessage = {
                _msgid: msg._msgid,
                payload: responsePayload,
                topic: msg.topic,
            };
            // TODO: send works but it has a problem with debug node and ByteString
            // I'm not sure what this comment refers to, but I'm leaving it just in case.
            // Means we can send ByteStrings here, but it was to notice, that the debug node of node-red had/has a problem with ByteStrings in the UI.
            this.send(responseMessage);
        });
        const getAdditionalEventFields = () => {
            switch (self.resultType) {
                case 'condition':
                    return (opcua_iiot_core_listener_1.default.getConditionFields());
                case 'state':
                    return (opcua_iiot_core_listener_1.default.getStateFields());
                case 'all':
                    return (opcua_iiot_core_listener_1.default.getAllEventFields());
                default:
                    return [];
            }
        };
    }
    RED.nodes.registerType('OPCUA-IIoT-Event', OPCUAIIoTEvent);
};

//# sourceMappingURL=opcua-iiot-event.js.map
